<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Screener - Top 100</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.png') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <!-- Container pour les notifications toast -->
        <div id="toastContainer" class="toast-container"></div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="brand">
                    <span class="brand-icon">‚óà</span>
                    <div class="brand-text">
                        <h1>Crypto Screener <span class="h4-badge">H4</span></h1>
                        <p class="subtitle">D√©tection de tendances sur le Top 100 <span class="separator">‚Ä¢</span> <span class="author">by <a href="https://x.com/cryptofit05" target="_blank" class="author-name">0xCesar</a></span></p>
                    </div>
                </div>
            </div>
            <div class="header-actions">
                <div class="status-indicator">
                    <span class="status-dot"></span>
                    <span class="status-text">Live</span>
                </div>
                <button class="btn btn-secondary" onclick="openSettings()">
                    <span class="btn-icon">‚öôÔ∏è</span> Param√®tres
                </button>
                <button id="refreshBtn" class="btn btn-primary" onclick="refreshData()">
                    <span class="btn-icon">‚Üª</span> Actualiser
                </button>
                <div class="last-update">
                    MAJ: <span id="lastUpdate">-</span>
                </div>
            </div>
        </header>

        <!-- Filtres -->
        <div class="filters">
            <div class="filter-group">
                <label>Filtrer par signal:</label>
                <div class="filter-buttons">
                    <button class="filter-btn active" data-filter="all" onclick="setFilter('all')">
                        Tous <span id="countAll" class="badge">0</span>
                    </button>
                    <button class="filter-btn filter-long" data-filter="long" onclick="setFilter('long')">
                        LONG <span id="countLong" class="badge">0</span>
                    </button>
                    <button class="filter-btn filter-short" data-filter="short" onclick="setFilter('short')">
                        SHORT <span id="countShort" class="badge">0</span>
                    </button>
                </div>
            </div>
            <div class="filter-group">
                <label>Minimum d'√©toiles:</label>
                <div class="star-filter">
                    <button class="star-btn active" data-stars="0" onclick="setMinStars(0)">Tous</button>
                    <button class="star-btn" data-stars="1" onclick="setMinStars(1)">‚≠ê+</button>
                    <button class="star-btn" data-stars="2" onclick="setMinStars(2)">‚≠ê‚≠ê+</button>
                    <button class="star-btn" data-stars="3" onclick="setMinStars(3)">‚≠ê‚≠ê‚≠ê+</button>
                    <button class="star-btn" data-stars="4" onclick="setMinStars(4)">‚≠ê‚≠ê‚≠ê‚≠ê+</button>
                    <button class="star-btn" data-stars="5" onclick="setMinStars(5)">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</button>
                </div>
            </div>
        </div>

        <!-- Indicateur de chargement -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Chargement des donn√©es...</p>
        </div>

        <!-- Tableau des cryptos -->
        <div id="tableContainer" class="table-container" style="display: none;">
            <table class="crypto-table">
                <thead>
                    <tr>
                        <th class="sortable" onclick="sortTable('name')">Crypto</th>
                        <th class="sortable" onclick="sortTable('price')">Prix (USDT)</th>
                        <th class="sortable" onclick="sortTable('stoch_rsi_k')">Stoch RSI</th>
                        <th class="sortable" onclick="sortTable('signal')">Signal</th>
                    </tr>
                </thead>
                <tbody id="cryptoTableBody">
                    <!-- Les donn√©es seront ins√©r√©es ici par JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- Message si aucun r√©sultat -->
        <div id="noResults" class="no-results" style="display: none;">
            <p>Aucune crypto ne correspond aux crit√®res s√©lectionn√©s.</p>
        </div>

        <!-- Footer avec l√©gende -->
        <footer class="footer">
            <div class="legend">
                <h3>üìä L√©gende des signaux</h3>
                <div class="legend-grid">
                    <div class="legend-item">
                        <span class="signal-badge long-strong">LONG</span>
                        <p>RSI Stoch < 20 = Setup optimal</p>
                    </div>
                    <div class="legend-item">
                        <span class="signal-badge short-strong">SHORT</span>
                        <p>RSI Stoch > 80 = Setup optimal</p>
                    </div>
                    <div class="legend-item">
                        <span class="signal-badge long-medium">LONG</span>
                        <p>RSI Stoch 20-40 = Bon setup</p>
                    </div>
                    <div class="legend-item">
                        <span class="signal-badge short-medium">SHORT</span>
                        <p>RSI Stoch 60-80 = Bon setup</p>
                    </div>
                </div>
            </div>
            <div class="footer-bottom">
                <p class="strategy-credit">üìà Strat√©gie √©labor√©e par <a href="https://x.com/Frenchie_" target="_blank" class="frenchie-name">Frenchie</a></p>
                <p class="copyright">D√©velopp√© avec ‚óà par <a href="https://x.com/cryptofit05" target="_blank" class="footer-author">0xCesar</a></p>
                <p class="data-source">Donn√©es: Binance API ‚Ä¢ CoinGecko</p>
            </div>
        </footer>
    </div>

    <!-- Modal Param√®tres -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">‚öôÔ∏è Param√®tres</h2>
                <button class="modal-close" onclick="closeSettings()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="settings-group">
                    <div class="settings-item">
                        <div>
                            <div class="settings-label">Mode clair</div>
                            <div class="settings-description">Basculer entre le th√®me sombre et clair</div>
                        </div>
                        <label class="switch">
                            <input type="checkbox" id="lightModeToggle" onchange="toggleTheme()">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="settings-item">
                        <div>
                            <div class="settings-label">Son des notifications</div>
                            <div class="settings-description">Jouer un son lors d'un nouveau signal</div>
                        </div>
                        <label class="switch">
                            <input type="checkbox" id="soundToggle" checked onchange="toggleSound()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== Variables globales ==========
        let allData = [];
        let currentFilter = 'all';
        let minStars = 0; // Filtre minimum d'√©toiles
        let sortColumn = 'signal';
        let sortDirection = 'asc';
        let autoRefreshInterval = null;
        const AUTO_REFRESH_DELAY = 15 * 60 * 1000; // 15 minutes
        
        // Tracking des tokens pour les notifications
        let knownSignals = new Set(); // Tokens d√©j√† vus avec un signal
        let isFirstLoad = true; // Pour √©viter les notifs au premier chargement
        let notificationsEnabled = false;
        let soundEnabled = true; // Son des notifications

        // ========== Syst√®me de notifications ==========
        
        /**
         * Demande la permission pour les notifications
         */
        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                notificationsEnabled = permission === 'granted';
                return notificationsEnabled;
            }
            return false;
        }

        /**
         * Joue un son de notification (bip)
         */
        function playNotificationSound() {
            if (!soundEnabled) return; // Ne pas jouer si d√©sactiv√©
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Cr√©er un oscillateur pour le bip
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Configuration du son
            oscillator.frequency.value = 800; // Fr√©quence en Hz
            oscillator.type = 'sine';
            
            // Volume
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            // Jouer le son
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
            
            // Deuxi√®me bip apr√®s 200ms
            setTimeout(() => {
                const osc2 = audioContext.createOscillator();
                const gain2 = audioContext.createGain();
                osc2.connect(gain2);
                gain2.connect(audioContext.destination);
                osc2.frequency.value = 1000;
                osc2.type = 'sine';
                gain2.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                osc2.start(audioContext.currentTime);
                osc2.stop(audioContext.currentTime + 0.3);
            }, 200);
        }

        /**
         * Affiche une notification pour un nouveau signal
         */
        function showSignalNotification(crypto) {
            const signalType = crypto.signal;
            const price = formatNumber(crypto.price, 8);
            
            // Notification browser
            if (notificationsEnabled && 'Notification' in window) {
                const notification = new Notification(`üö® Nouveau setup ${signalType}`, {
                    body: `${crypto.name} propose un setup ${signalType} au prix de ${price} USDT`,
                    icon: crypto.image || '/static/icon.png',
                    tag: crypto.symbol, // √âvite les doublons
                    requireInteraction: false
                });
                
                // Fermer apr√®s 10 secondes
                setTimeout(() => notification.close(), 10000);
            }
            
            // Notification visuelle sur la page
            showToast(crypto);
        }

        /**
         * Affiche un toast de notification sur la page
         */
        function showToast(crypto) {
            const toastContainer = document.getElementById('toastContainer');
            const signalClass = crypto.signal.toLowerCase();
            const price = formatNumber(crypto.price, 8);
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${signalClass}`;
            toast.innerHTML = `
                <div class="toast-icon">
                    <img src="${crypto.image}" alt="${crypto.name}" onerror="this.style.display='none'">
                </div>
                <div class="toast-content">
                    <div class="toast-title">üö® Nouveau setup ${crypto.signal}</div>
                    <div class="toast-body">${crypto.name} √† ${price} USDT</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
            `;
            
            toastContainer.appendChild(toast);
            
            // Animation d'entr√©e
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Supprimer apr√®s 8 secondes
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 8000);
        }

        /**
         * V√©rifie les nouveaux signaux et envoie des notifications
         */
        function checkNewSignals(data) {
            if (isFirstLoad) {
                // Premier chargement : on enregistre tous les signaux existants
                data.forEach(crypto => {
                    if (crypto.signal === 'LONG' || crypto.signal === 'SHORT') {
                        knownSignals.add(crypto.symbol);
                    }
                });
                isFirstLoad = false;
                return;
            }
            
            // V√©rifier les nouveaux signaux
            const newSignals = [];
            data.forEach(crypto => {
                if ((crypto.signal === 'LONG' || crypto.signal === 'SHORT') && !knownSignals.has(crypto.symbol)) {
                    newSignals.push(crypto);
                    knownSignals.add(crypto.symbol);
                }
            });
            
            // Retirer les tokens qui n'ont plus de signal
            const currentSignalSymbols = new Set(data.filter(c => c.signal === 'LONG' || c.signal === 'SHORT').map(c => c.symbol));
            knownSignals.forEach(symbol => {
                if (!currentSignalSymbols.has(symbol)) {
                    knownSignals.delete(symbol);
                }
            });
            
            // Notifier pour chaque nouveau signal
            if (newSignals.length > 0) {
                playNotificationSound();
                newSignals.forEach(crypto => showSignalNotification(crypto));
            }
        }

        // ========== Fonctions principales ==========

        /**
         * Charge les donn√©es depuis l'API
         */
        async function loadData() {
            showLoading(true);
            
            try {
                const response = await fetch('/api/data');
                const result = await response.json();
                
                if (result.success) {
                    // V√©rifier les nouveaux signaux avant de mettre √† jour
                    checkNewSignals(result.data);
                    
                    // Trier les donn√©es par signal_score d√®s la r√©ception
                    // Score bas = meilleur setup LONG (RSI bas) ou SHORT (RSI haut)
                    allData = result.data.sort((a, b) => {
                        const scoreA = a.signal_score !== undefined ? a.signal_score : 200;
                        const scoreB = b.signal_score !== undefined ? b.signal_score : 200;
                        return scoreA - scoreB;
                    });
                    
                    updateLastUpdate(result.last_update);
                    updateCounts();
                    renderTable();
                } else {
                    console.error('Erreur lors du chargement des donn√©es');
                }
            } catch (error) {
                console.error('Erreur:', error);
            } finally {
                showLoading(false);
            }
        }

        /**
         * Force le rafra√Æchissement des donn√©es
         */
        async function refreshData() {
            const btn = document.getElementById('refreshBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="btn-icon">‚è≥</span> Chargement...';
            
            try {
                // Demander un rafra√Æchissement au serveur
                await fetch('/api/refresh');
                
                // Attendre un peu que le serveur r√©cup√®re les donn√©es
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Recharger les donn√©es
                await loadData();
            } catch (error) {
                console.error('Erreur lors du rafra√Æchissement:', error);
            } finally {
                btn.disabled = false;
                btn.innerHTML = '<span class="btn-icon">üîÑ</span> Rafra√Æchir';
            }
        }

        /**
         * Met √† jour l'affichage de la derni√®re mise √† jour
         */
        function updateLastUpdate(timestamp) {
            const element = document.getElementById('lastUpdate');
            if (timestamp) {
                const date = new Date(timestamp);
                element.textContent = date.toLocaleTimeString('fr-FR');
            } else {
                element.textContent = '-';
            }
        }

        /**
         * Met √† jour les compteurs de filtres
         */
        function updateCounts() {
            const countAll = allData.length;
            const countLong = allData.filter(d => d.signal === 'LONG').length;
            const countShort = allData.filter(d => d.signal === 'SHORT').length;
            
            document.getElementById('countAll').textContent = countAll;
            document.getElementById('countLong').textContent = countLong;
            document.getElementById('countShort').textContent = countShort;
        }

        /**
         * D√©finit le filtre actif
         */
        function setFilter(filter) {
            currentFilter = filter;
            
            // Mettre √† jour les boutons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.filter === filter) {
                    btn.classList.add('active');
                }
            });
            
            renderTable();
        }

        /**
         * D√©finit le filtre minimum d'√©toiles
         */
        function setMinStars(stars) {
            minStars = stars;
            
            // Mettre √† jour les boutons
            document.querySelectorAll('.star-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.stars) === stars) {
                    btn.classList.add('active');
                }
            });
            
            renderTable();
        }

        /**
         * Filtre les donn√©es selon le filtre actif et les √©toiles minimum
         */
        function filterData(data) {
            let filtered = data;
            
            // Filtre par signal
            switch (currentFilter) {
                case 'long':
                    filtered = filtered.filter(d => d.signal === 'LONG');
                    break;
                case 'short':
                    filtered = filtered.filter(d => d.signal === 'SHORT');
                    break;
            }
            
            // Filtre par nombre d'√©toiles minimum
            if (minStars > 0) {
                filtered = filtered.filter(d => d.rating >= minStars);
            }
            
            return filtered;
        }

        /**
         * Trie le tableau par colonne
         */
        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            renderTable();
        }

        /**
         * Trie les donn√©es
         */
        function sortData(data) {
            const sorted = [...data];
            
            sorted.sort((a, b) => {
                // Pour le tri par signal:
                // 1. D'abord par rating (note) d√©croissant (5 √©toiles en premier)
                // 2. √Ä rating √©gal, par FDV d√©croissante
                // 3. En dernier, par RSI optimal
                if (sortColumn === 'signal') {
                    const ratingA = a.rating || 0;
                    const ratingB = b.rating || 0;
                    
                    // 1. Trier par rating d√©croissant
                    if (ratingA !== ratingB) {
                        return ratingB - ratingA; // Plus haute note en premier
                    }
                    
                    // 2. √Ä rating √©gal, trier par FDV d√©croissante
                    const fdvA = a.fdv || 0;
                    const fdvB = b.fdv || 0;
                    if (fdvA !== fdvB) {
                        return fdvB - fdvA; // Plus grande FDV en premier
                    }
                    
                    // 3. En dernier, trier par RSI optimal
                    // LONG: RSI bas = meilleur, SHORT: RSI haut = meilleur
                    const rsiA = a.stoch_rsi_k || 50;
                    const rsiB = b.stoch_rsi_k || 50;
                    
                    if (a.signal === 'LONG') {
                        return rsiA - rsiB; // RSI bas en premier pour LONG
                    } else {
                        return rsiB - rsiA; // RSI haut en premier pour SHORT
                    }
                }
                
                let valA = a[sortColumn];
                let valB = b[sortColumn];
                
                // Comparaison standard pour les autres colonnes
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                } else {
                    return sortDirection === 'asc' 
                        ? String(valA).localeCompare(String(valB))
                        : String(valB).localeCompare(String(valA));
                }
            });
            
            return sorted;
        }

        /**
         * Formate un nombre pour l'affichage
         */
        function formatNumber(num, decimals = 2) {
            if (num === null || num === undefined) return '-';
            
            // Pour les tr√®s petits nombres (< 0.01)
            if (num < 0.01 && num > 0) {
                return num.toFixed(8);
            }
            
            // Pour les grands nombres
            if (num >= 1000) {
                return num.toLocaleString('fr-FR', { 
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2 
                });
            }
            
            return num.toFixed(decimals);
        }

        /**
         * G√©n√®re le HTML pour une ligne du tableau
         */
        function createTableRow(crypto) {
            const signalClass = crypto.signal.toLowerCase();
            
            // D√©terminer la force du signal bas√©e sur la note (rating)
            let signalStrength = '';
            if (crypto.signal === 'LONG' || crypto.signal === 'SHORT') {
                if (crypto.rating >= 4) {
                    signalStrength = 'strong';
                } else if (crypto.rating >= 2) {
                    signalStrength = 'medium';
                } else {
                    signalStrength = 'weak';
                }
            }
            
            const strengthClass = signalStrength ? `${signalClass}-${signalStrength}` : signalClass;
            
            // Cr√©er les indicateurs de la note
            const ratingStars = crypto.rating_text || '-';
            const ratingIndicators = [];
            if (crypto.has_ema) ratingIndicators.push('<span class="indicator ema" title="EMAs align√©es">EMA</span>');
            if (crypto.has_rsi) ratingIndicators.push('<span class="indicator rsi" title="RSI Stoch optimal">RSI</span>');
            if (crypto.has_sr) ratingIndicators.push('<span class="indicator sr" title="Proche S/R">S/R</span>');
            
            // D√©terminer si la ligne est cliquable (a un signal)
            const isClickable = crypto.signal === 'LONG' || crypto.signal === 'SHORT';
            const clickHandler = isClickable ? `onclick="openChart('${crypto.name}')"` : '';
            
            // Sources d'images multiples pour garantir l'affichage
            // 1. CoinGecko (source principale)
            // 2. GitHub cryptocurrency-icons (fallback fiable)
            // 3. Avatar g√©n√©r√© (dernier recours)
            const githubIcon = `https://raw.githubusercontent.com/spothq/cryptocurrency-icons/master/128/color/${crypto.name.toLowerCase()}.png`;
            const avatarFallback = `https://ui-avatars.com/api/?name=${crypto.name}&background=random&color=fff&size=48&bold=true`;
            
            return `
                <tr class="crypto-row ${signalClass !== 'aucun' ? 'has-signal' : ''}" ${clickHandler}>
                    <td class="crypto-name">
                        <img src="${crypto.image}" alt="${crypto.name}" class="crypto-icon" onerror="this.onerror=function(){this.src='${avatarFallback}'}; this.src='${githubIcon}';">
                        <span class="crypto-label">${crypto.name}</span>
                    </td>
                    <td class="price">${formatNumber(crypto.price, 8)}</td>
                    <td class="stoch-rsi">
                        <div class="stoch-values">
                            <span class="stoch-k">K: ${formatNumber(crypto.stoch_rsi_k)}</span>
                            <span class="stoch-d">D: ${formatNumber(crypto.stoch_rsi_d)}</span>
                        </div>
                        <div class="stoch-bar">
                            <div class="stoch-fill" style="width: ${Math.min(100, crypto.stoch_rsi_k)}%"></div>
                        </div>
                    </td>
                    <td class="signal-cell">
                        <div class="signal-with-rating">
                            <span class="signal-badge ${strengthClass}">${crypto.signal}</span>
                            ${crypto.signal !== 'AUCUN' ? `
                                <div class="rating-info">
                                    <span class="rating-stars">${ratingStars}</span>
                                    <div class="rating-indicators">${ratingIndicators.join('')}</div>
                                </div>
                            ` : ''}
                        </div>
                    </td>
                </tr>
            `;
        }

        /**
         * Affiche le tableau des cryptos
         */
        function renderTable() {
            const tableBody = document.getElementById('cryptoTableBody');
            const tableContainer = document.getElementById('tableContainer');
            const noResults = document.getElementById('noResults');
            
            // Filtrer et trier les donn√©es
            let filteredData = filterData(allData);
            let sortedData = sortData(filteredData);
            
            if (sortedData.length === 0) {
                tableContainer.style.display = 'none';
                noResults.style.display = 'block';
            } else {
                tableContainer.style.display = 'block';
                noResults.style.display = 'none';
                tableBody.innerHTML = sortedData.map(createTableRow).join('');
            }
        }

        /**
         * Affiche/masque l'indicateur de chargement
         */
        function showLoading(show) {
            const loading = document.getElementById('loading');
            const tableContainer = document.getElementById('tableContainer');
            
            if (show) {
                loading.style.display = 'flex';
                tableContainer.style.display = 'none';
            } else {
                loading.style.display = 'none';
            }
        }

        /**
         * Active le rafra√Æchissement automatique (toujours activ√©)
         */
        function startAutoRefresh() {
            autoRefreshInterval = setInterval(loadData, AUTO_REFRESH_DELAY);
            console.log('Rafra√Æchissement automatique activ√©');
        }

        // ========== TradingView Chart ==========
        
        /**
         * Ouvre le graphique TradingView pour un token
         * Priorit√©: Binance > Bitget > Coinbase > Kraken > autres
         */
        function openChart(symbol) {
            // Format du symbole pour TradingView: EXCHANGE:SYMBOLUSDT
            // On pr√©f√®re Binance car c'est le plus liquide
            const exchanges = [
                'BINANCE',
                'BITGET', 
                'COINBASE',
                'KRAKEN'
            ];
            
            // Utiliser Binance par d√©faut (le plus liquide)
            const exchange = exchanges[0];
            const tvSymbol = `${exchange}:${symbol}USDT`;
            
            // Ouvrir TradingView en timeframe 4H
            const url = `https://www.tradingview.com/chart/?symbol=${tvSymbol}&interval=240`;
            window.open(url, '_blank');
        }

        // ========== Param√®tres ==========
        
        /**
         * Ouvre le modal des param√®tres
         */
        function openSettings() {
            document.getElementById('settingsModal').classList.add('open');
        }
        
        /**
         * Ferme le modal des param√®tres
         */
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('open');
        }
        
        /**
         * Bascule entre le th√®me clair et sombre
         */
        function toggleTheme() {
            const isLightMode = document.getElementById('lightModeToggle').checked;
            document.body.classList.toggle('light-mode', isLightMode);
            localStorage.setItem('theme', isLightMode ? 'light' : 'dark');
        }
        
        /**
         * Active/d√©sactive le son des notifications
         */
        function toggleSound() {
            soundEnabled = document.getElementById('soundToggle').checked;
            localStorage.setItem('soundEnabled', soundEnabled);
        }
        
        /**
         * Charge les pr√©f√©rences sauvegard√©es
         */
        function loadPreferences() {
            // Th√®me
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.getElementById('lightModeToggle').checked = true;
            }
            
            // Son
            const savedSound = localStorage.getItem('soundEnabled');
            if (savedSound !== null) {
                soundEnabled = savedSound === 'true';
                document.getElementById('soundToggle').checked = soundEnabled;
            }
        }
        
        // Fermer le modal en cliquant √† l'ext√©rieur
        document.getElementById('settingsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeSettings();
            }
        });

        // ========== Initialisation ==========
        document.addEventListener('DOMContentLoaded', async function() {
            // Charger les pr√©f√©rences utilisateur
            loadPreferences();
            
            // Demander la permission pour les notifications
            await requestNotificationPermission();
            
            // Charger les donn√©es initiales
            loadData();
            
            // Activer le rafra√Æchissement automatique (toujours activ√©)
            startAutoRefresh();
        });
    </script>
</body>
</html>